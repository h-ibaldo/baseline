<script lang="ts">
	/**
	 * Canvas - The main page builder canvas
	 *
	 * Features:
	 * - Infinite scrollable canvas
	 * - Zoom in/out with mouse wheel
	 * - Pan with space + drag
	 * - Multi-page support (Figma-style)
	 * - Baseline grid overlay
	 * - Element rendering and interaction
	 */

	import { onMount, onDestroy } from 'svelte';
	import {
		designState,
		currentPage,
		initialize,
		createElement,
		selectElement,
		clearSelection,
		selectedElements
	} from '$lib/stores/design-store';
	import { currentTool } from '$lib/stores/tool-store';
	import CanvasElement from './CanvasElement.svelte';
	import BaselineGrid from './BaselineGrid.svelte';
	import SelectionOverlay from './SelectionOverlay.svelte';
	import SelectionBox from './SelectionBox.svelte';

	let canvasElement: HTMLDivElement;
	let viewport = { x: 0, y: 0, scale: 1 };
	let isDragging = false;
	let dragStart = { x: 0, y: 0 };
	let isPanning = false;
	let selectionOverlay: any = undefined; // Reference to SelectionOverlay
	
	// Update canvas cursor based on tool and state
	$: {
		if (canvasElement) {
			if (isDragging && ($currentTool === 'hand' || isPanning)) {
				canvasElement.style.cursor = 'grabbing';
			} else if ($currentTool === 'hand' || isPanning) {
				canvasElement.style.cursor = 'grab';
			} else {
				canvasElement.style.cursor = 'default';
			}
		}
	}

	// Drawing state (for creating new elements)
	let isDrawing = false;
	let drawStart = { x: 0, y: 0 };
	let drawPreview: {
		x: number;
		y: number;
		width: number;
		height: number;
	} | null = null;

	// Zoom settings
	const MIN_ZOOM = 0.1;
	const MAX_ZOOM = 4;
	const ZOOM_STEP = 0.1;

	onMount(async () => {
		await initialize();
		setupEventListeners();
	});

	function setupEventListeners() {
		if (typeof window === 'undefined') return;

		// Mouse wheel for zoom
		canvasElement.addEventListener('wheel', handleWheel, { passive: false });

		// Space key for panning
		window.addEventListener('keydown', handleKeyDown);
		window.addEventListener('keyup', handleKeyUp);
	}

	onDestroy(() => {
		if (typeof window === 'undefined') return;

		canvasElement?.removeEventListener('wheel', handleWheel);
		window.removeEventListener('keydown', handleKeyDown);
		window.removeEventListener('keyup', handleKeyUp);
	});

	function handleWheel(e: WheelEvent) {
		// Zoom with Cmd/Ctrl + wheel
		if (e.metaKey || e.ctrlKey) {
			e.preventDefault();

			const delta = -e.deltaY * 0.001;
			const newScale = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, viewport.scale + delta));

			// Zoom towards mouse position
			const rect = canvasElement.getBoundingClientRect();
			const mouseX = e.clientX - rect.left;
			const mouseY = e.clientY - rect.top;

			const oldScale = viewport.scale;
			const scaleRatio = newScale / oldScale;

			viewport = {
				x: mouseX - (mouseX - viewport.x) * scaleRatio,
				y: mouseY - (mouseY - viewport.y) * scaleRatio,
				scale: newScale
			};
		}
		// Pan with shift + wheel (horizontal) or plain wheel (vertical)
		else {
			e.preventDefault();
			viewport = {
				...viewport,
				x: viewport.x - (e.shiftKey ? e.deltaY : e.deltaX),
				y: viewport.y - (e.shiftKey ? 0 : e.deltaY)
			};
		}
	}

	function handleKeyDown(e: KeyboardEvent) {
		if (e.code === 'Space' && !isPanning) {
			e.preventDefault();
			isPanning = true;
		}
	}

	function handleKeyUp(e: KeyboardEvent) {
		if (e.code === 'Space') {
			isPanning = false;
			if (isDragging) {
				isDragging = false;
			}
		}
	}

	function handleMouseDown(e: MouseEvent) {
		const tool = $currentTool;

		// Hand tool or Space key = panning (works even over elements)
		if (tool === 'hand' || isPanning) {
			isDragging = true;
			dragStart = { x: e.clientX - viewport.x, y: e.clientY - viewport.y };
			e.preventDefault();
			return;
		}

		// Only handle clicks on the canvas background for other tools
		if (e.target !== e.currentTarget) return;

		// Move tool: clear selection when clicking canvas background
		if (tool === 'move') {
			clearSelection();
			return;
		}

		// Drawing tools: div, text, media
		if (tool === 'div' || tool === 'text' || tool === 'media') {
			isDrawing = true;

			// Convert screen coordinates to canvas coordinates (accounting for viewport)
			const rect = canvasElement.getBoundingClientRect();
			const canvasX = (e.clientX - rect.left - viewport.x) / viewport.scale;
			const canvasY = (e.clientY - rect.top - viewport.y) / viewport.scale;

			drawStart = { x: canvasX, y: canvasY };
			drawPreview = { x: canvasX, y: canvasY, width: 0, height: 0 };
			e.preventDefault();
		}
	}

	function handleMouseMove(e: MouseEvent) {
		// Panning
		if (isDragging && !isDrawing) {
			viewport = {
				...viewport,
				x: e.clientX - dragStart.x,
				y: e.clientY - dragStart.y
			};
			return;
		}

		// Drawing preview
		if (isDrawing && drawPreview) {
			const rect = canvasElement.getBoundingClientRect();
			const canvasX = (e.clientX - rect.left - viewport.x) / viewport.scale;
			const canvasY = (e.clientY - rect.top - viewport.y) / viewport.scale;

			// Calculate position and size supporting all 4 quadrants
			const x = Math.min(drawStart.x, canvasX);
			const y = Math.min(drawStart.y, canvasY);
			const width = Math.abs(canvasX - drawStart.x);
			const height = Math.abs(canvasY - drawStart.y);

			drawPreview = { x, y, width, height };
		}
	}

	async function handleMouseUp() {
		// Finish panning
		if (isDragging && !isDrawing) {
			isDragging = false;
			return;
		}

		// Finish drawing and create element
		if (isDrawing && drawPreview) {
			const tool = $currentTool;
			const MIN_SIZE = 10; // Minimum size to create element
			let newElementId: string;

			// Get current page ID
			const pageId = $designState.currentPageId;
			if (!pageId) {
				console.error('No current page ID');
				return;
			}

			// If dragged less than MIN_SIZE, create default-sized element
			if (drawPreview.width < MIN_SIZE || drawPreview.height < MIN_SIZE) {
				// Click: create default size centered at click position
				const defaultSizes = {
					div: { width: 200, height: 200 },
					text: { width: 300, height: 100 },
					media: { width: 200, height: 200 }
				};

				const size = defaultSizes[tool as 'div' | 'text' | 'media'] || { width: 200, height: 200 };

				// Center element at click position
				newElementId = await createElement({
					pageId,
					parentId: null,
					elementType: tool === 'text' ? 'p' : tool === 'media' ? 'img' : 'div',
					position: {
						x: drawStart.x - size.width / 2,
						y: drawStart.y - size.height / 2
					},
					size,
					content: tool === 'text' ? 'Text' : '',
					styles: {
						backgroundColor: tool === 'div' ? '#f5f5f5' : undefined,
						color: '#000000'
					}
				});
			} else {
				// Drag: create element with drawn size
				newElementId = await createElement({
					pageId,
					parentId: null,
					elementType: tool === 'text' ? 'p' : tool === 'media' ? 'img' : 'div',
					position: { x: drawPreview.x, y: drawPreview.y },
					size: { width: drawPreview.width, height: drawPreview.height },
					content: tool === 'text' ? 'Text' : '',
					styles: {
						backgroundColor: tool === 'div' ? '#f5f5f5' : undefined,
						color: '#000000'
					}
				});
			}

			// Automatically select the newly created element
			selectElement(newElementId);

			// Reset drawing state (keep tool selected)
			isDrawing = false;
			drawPreview = null;

			// Don't switch back to move tool - keep current tool selected
		}
	}

	// Zoom controls
	function zoomIn() {
		viewport = {
			...viewport,
			scale: Math.min(MAX_ZOOM, viewport.scale + ZOOM_STEP)
		};
	}

	function zoomOut() {
		viewport = {
			...viewport,
			scale: Math.max(MIN_ZOOM, viewport.scale - ZOOM_STEP)
		};
	}

	function resetZoom() {
		viewport = { x: 0, y: 0, scale: 1 };
	}
</script>

<!-- STYLE: Canvas container - full viewport, overflow hidden -->
<div class="canvas-container">
	<!-- STYLE: Zoom controls - floating toolbar, top-right corner -->
	<div class="zoom-controls">
		<button on:click={zoomOut}>-</button>
		<span>{Math.round(viewport.scale * 100)}%</span>
		<button on:click={zoomIn}>+</button>
		<button on:click={resetZoom}>Reset</button>
	</div>

	<!-- STYLE: Canvas - infinite scrollable area, dark background -->
	<div
		class="canvas"
		bind:this={canvasElement}
		on:mousedown={handleMouseDown}
		on:mousemove={handleMouseMove}
		on:mouseup={handleMouseUp}
		on:mouseleave={handleMouseUp}
		role="application"
		aria-label="Page builder canvas"
	>
		<!-- STYLE: Canvas viewport - transformed container with zoom/pan -->
		<div
			class="canvas-viewport"
			style="transform: translate({viewport.x}px, {viewport.y}px) scale({viewport.scale});"
		>
			<!-- Render all root elements (no parent) directly on infinite canvas -->
			{#each Object.values($designState.elements).filter(el => el.parentId === null) as element}
				<CanvasElement
					{element}
					{isPanning}
					{isDragging}
					onStartDrag={selectionOverlay ? (e, el) => selectionOverlay.startDrag(e, el) : undefined}
				/>
			{/each}

			<!-- Drawing preview - actual element being drawn -->
			{#if drawPreview && drawPreview.width > 0 && drawPreview.height > 0}
				<div
					class="element-preview"
					style="
						position: absolute;
						left: {drawPreview.x}px;
						top: {drawPreview.y}px;
						width: {drawPreview.width}px;
						height: {drawPreview.height}px;
						background-color: {$currentTool === 'div' ? '#f5f5f5' : $currentTool === 'text' ? 'transparent' : '#e5e7eb'};
						color: #000000;
						border: 2px solid #3b82f6;
						opacity: 0.8;
					"
				>
					{#if $currentTool === 'text'}
						<span style="padding: 8px; display: block;">Text</span>
					{/if}
				</div>
			{/if}

			<!-- Render frames as visual artboards (breakpoints) -->
			{#each Object.values($designState.frames) as frame}
				<div
					class="frame-artboard"
					style="
						position: absolute;
						left: {frame.position.x}px;
						top: {frame.position.y}px;
						width: {frame.breakpointWidth}px;
						height: {frame.height}px;
					"
				>
					<!-- Baseline grid per frame -->
					<BaselineGrid />
					
					<div class="frame-artboard-label">
						{frame.name} ({frame.breakpointWidth}px)
					</div>
				</div>
			{/each}
		</div>

		<!-- Selection Overlay - handles selection UI and interactions -->
		<SelectionOverlay bind:this={selectionOverlay} {viewport} {isPanning} selectedElements={$selectedElements} />
		
		<!-- Selection Box - multi-select by dragging -->
		<SelectionBox {canvasElement} {viewport} />
	</div>
</div>

<style>
	/* STYLE: Add your design here! */
	/* This is unstyled semantic HTML with functional logic */

	.canvas-container {
		position: relative;
		width: 100%;
		height: 100vh;
		padding-top: 60px; /* Space for top toolbar */
		overflow: hidden;
		background: #1a1a1a; /* Dark canvas background */
		box-sizing: border-box;
	}

	.zoom-controls {
		position: absolute;
		bottom: 20px;
		right: 20px;
		z-index: 100;
		display: flex;
		gap: 8px;
		padding: 8px;
		background: white;
		border-radius: 4px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	}

	.zoom-controls button {
		padding: 4px 12px;
		border: 1px solid #ddd;
		background: white;
		cursor: pointer;
	}

	.zoom-controls button:hover {
		background: #f5f5f5;
	}

	.zoom-controls span {
		padding: 4px 8px;
		font-size: 14px;
		color: #333;
	}

	.canvas {
		width: 100%;
		height: 100%;
		position: relative;
		cursor: default;
	}

	.canvas-viewport {
		transform-origin: 0 0;
		will-change: transform;
	}

	.frame-artboard {
		position: absolute;
		border: 2px solid rgba(100, 100, 255, 0.3);
		background: rgba(255, 255, 255, 0.02);
		pointer-events: none;
	}

	.frame-artboard-label {
		position: absolute;
		top: -30px;
		left: 0;
		color: rgba(100, 100, 255, 0.8);
		font-size: 14px;
		font-weight: 500;
		pointer-events: none;
	}

	/* Element preview while drawing */
	.element-preview {
		pointer-events: none;
		z-index: 1000;
		box-sizing: border-box;
	}
</style>
